<style>
  .mini-title{
    margin: 8px 0 4px;
    font-size: 14px;
    color: #bdbdbd;
    text-align: center;
    letter-spacing: .2px;
  }
  .mini-svg{
    width: 100%;
    height: auto;
    display: block;
  }
  /* стили прямоугольников */
  .bar-track{ fill:#333; }
  .bar-fill{  rx: 9; ry: 9; } /* скругление углов заполнения */
  .bar-label{
    fill:#bdbdbd; font: 12px/1 sans-serif; text-anchor:end; dominant-baseline:middle;
  }
  .bar-value{
    fill:#e6e6e6; font: 12px/1 sans-serif; dominant-baseline:middle;
  }
</style>

<div class="gauge-card">
  <h3 class="gauge-title">Котлы</h3>
  <svg id="gauge-1" class="gauge-svg" viewBox="0 0 320 180" preserveAspectRatio="xMidYMid meet"></svg>

  <!-- мини-гистограмма (слева) -->
  <div class="mini-title">Котлы — по станциям</div>
  <svg id="bars-boilers" class="mini-svg"></svg>
</div>

<div class="gauge-card">
  <h3 class="gauge-title">Турбины</h3>
  <svg id="gauge-2" class="gauge-svg" viewBox="0 0 320 180" preserveAspectRatio="xMidYMid meet"></svg>

  <!-- мини-гистограмма (справа) -->
  <div class="mini-title">Турбины — по станциям</div>
  <svg id="bars-turbines" class="mini-svg"></svg>
</div>

<script>
  // --- утилита: плавный цвет от красного к зелёному по значению 0..100
  const _interpRY = d3.interpolateRgb("#ff2d2d", "#ffd400");
  const _interpYG = d3.interpolateRgb("#ffd400", "#00d26a");
  function colorFor(v){
    const t = Math.max(0, Math.min(1, v/100));
    return t < 0.5 ? _interpRY(t*2) : _interpYG((t-0.5)*2);
  }

  // --- вычисляем компактные «оценки» 0..100 по станциям
  // КОТЛЫ: score = (факт КПД / норм КПД)*100 (усечение 0..100), средневзвешенное по Production
  function computeBoilerStationScores(){
    const acc = {};
    boilersData.forEach(item=>{
      const sid = item.StationID;
      const norm = (kpdvalues[sid] && kpdvalues[sid][item.BoilerID]) ? kpdvalues[sid][item.BoilerID] : 91;
      const score = Math.max(0, Math.min(100, (item.KPD / norm) * 100));
      const w = +item.Production || 1;
      if(!acc[sid]) acc[sid] = {sum:0, wsum:0};
      acc[sid].sum += score * w; acc[sid].wsum += w;
    });
    return Object.keys(acc).map(sid=>({
      label: stations[sid],
      value: acc[sid].wsum ? acc[sid].sum / acc[sid].wsum : 0
    })).sort((a,b)=>b.value-a.value);
  }

  // ТУРБИНЫ: score = (норма URT / факт URT)*100 (чем ниже URT, тем выше score), средневзвешенное по Consumption
  function computeTurbineStationScores(){
    const acc = {};
    turbinsData.forEach(item=>{
      const sid = item.stationID;
      const tid = parseInt(item.turbinID);
      const norm = (urtvalues[sid] && urtvalues[sid][tid]) ? urtvalues[sid][tid] : 2300;
      const score = Math.max(0, Math.min(100, (norm / item.URT) * 100));
      const w = +item.Consumption || 1;
      if(!acc[sid]) acc[sid] = {sum:0, wsum:0};
      acc[sid].sum += score * w; acc[sid].wsum += w;
    });
    return Object.keys(acc).map(sid=>({
      label: stations[sid],
      value: acc[sid].wsum ? acc[sid].sum / acc[sid].wsum : 0
    })).sort((a,b)=>b.value-a.value);
  }

  // --- отрисовка минималистичной горизонтальной гистограммы
  // rows: [{label, value(0..100)}]
  function drawMiniBars(svgId, rows, opts={}){
    const svg = d3.select('#'+svgId);
    svg.selectAll('*').remove();

    const barH = opts.barHeight ?? 18;
    const gap  = opts.gap ?? 8;
    const padL = opts.leftPad ?? 96;   // место под подписи слева
    const padR = opts.rightPad ?? 40;  // место под числа справа
    const padT = 8, padB = 12;

    const W = 320; // базовая ширина viewBox (SVG будет растягиваться по ширине карточки)
    const innerW = W - padL - padR;
    const H = padT + rows.length*(barH+gap) - gap + padB;

    svg.attr('viewBox', `0 0 ${W} ${H}`);

    const x = d3.scaleLinear().domain([0,100]).range([0, innerW]);

    // фоновые треки
    const g = svg.append('g').attr('transform', `translate(${padL},${padT})`);
    rows.forEach((d, i)=>{
      const y = i*(barH+gap);
      // трек
      g.append('rect')
        .attr('class','bar-track')
        .attr('x',0).attr('y',y)
        .attr('width', innerW).attr('height', barH)
        .attr('rx', barH/2).attr('ry', barH/2);
      // заполнение
      g.append('rect')
        .attr('class','bar-fill')
        .attr('x',0).attr('y',y)
        .attr('width', x(d.value)).attr('height', barH)
        .attr('fill', colorFor(d.value))
        .attr('rx', barH/2).attr('ry', barH/2);
    });

    // подписи слева
    const labels = svg.append('g').attr('transform', `translate(${padL-8},${padT})`);
    labels.selectAll('text').data(rows).enter().append('text')
      .attr('class','bar-label')
      .attr('x',0)
      .attr('y', (_,i)=> i*(barH+gap) + barH/2 + .5)
      .text(d=>d.label);

    // значения (внутри или сразу после заполнения — что ближе)
    const vals = svg.append('g').attr('transform', `translate(${padL},${padT})`);
    vals.selectAll('text').data(rows).enter().append('text')
      .attr('class','bar-value')
      .attr('x', d=>{
        const w = x(d.value);
        return w > 40 ? w - 8 : w + 8; // если полоса длинная — текст внутри справа, иначе снаружи
      })
      .attr('y', (_,i)=> i*(barH+gap) + barH/2 + .5)
      .attr('text-anchor', d=> x(d.value) > 40 ? 'end' : 'start')
      .text(d=> `${d.value.toFixed(0)}%`);
  }

  // --- данные и отрисовка
  const boilerBars  = computeBoilerStationScores();   // [{label, value}]
  const turbineBars = computeTurbineStationScores();  // [{label, value}]

  drawMiniBars('bars-boilers',  boilerBars);
  drawMiniBars('bars-turbines', turbineBars);
</script>
