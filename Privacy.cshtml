<script>
// формат числа "1 234"
const _fmtInt = d3.format(",");
const fmtTU = v => _fmtInt(Math.round(+v||0)).replace(/,/g," ");

// общий максимум (если нужно)
function computeSharedMax(datasets){
  let m = 0;
  datasets.forEach(rows => rows.forEach(d => { m = Math.max(m, +d.a||0, +d.b||0); }));
  return m * 1.05; // небольшой запас
}

// ДВОЙНЫЕ БАРЫ: линия слева, подпись перед линией, бары вправо (левый край прямой, правый скруглён)
// rows: [{label, a, b}], opts: {sharedMax, unit, barHeight, gap}
function drawDualBars(svgId, rows, opts = {}) {
  const UNIT = opts.unit || 'ТУТ';

  const svg = d3.select('#'+svgId);
  svg.selectAll('*').remove();

  const barH = opts.barHeight ?? 22;   // высота дорожки
  const gap  = opts.gap ?? 10;
  const minPadLbl = 90;                // минимум слева под подпись показателя
  const minPadVal = 70;                // минимум справа под вывод значений
  const padT = 8, padB = 12;
  const W = 320;                       // viewBox — SVG резиновый

  // 1) замеряем реальные ширины подписей и значений
  const meas = svg.append('g').attr('opacity', 0);
  const mLabel = meas.append('text').attr('class','bar-label');
  const mValue = meas.append('text').attr('class','bar-value');

  const labelTexts = rows.map(d => d.label);
  const valueTexts = rows.flatMap(d => [ `${fmtTU(d.a)} ${UNIT}`, `${fmtTU(d.b)} ${UNIT}` ]);

  const wLabel = s => { mLabel.text(s); return mLabel.node().getComputedTextLength(); };
  const wValue = s => { mValue.text(s); return mValue.node().getComputedTextLength(); };

  let maxLabelW = 0; labelTexts.forEach(s => maxLabelW = Math.max(maxLabelW, wLabel(s)));
  let maxValueW = 0; valueTexts.forEach(s => maxValueW = Math.max(maxValueW, wValue(s)));
  meas.remove();

  // поля: слева под подпись, справа под числа
  let padLbl = Math.max(minPadLbl, Math.ceil(maxLabelW) + 12);
  let padVal = Math.max(minPadVal, Math.ceil(maxValueW) + 10);

  // гарантированный минимум ширины под бары
  const minBarW = 100;
  padLbl = Math.min(padLbl, W - padVal - minBarW);

  const innerW = Math.max(minBarW, W - padLbl - padVal);
  const H = padT + rows.length*(barH+gap) - gap + padB;
  svg.attr('viewBox', `0 0 ${W} ${H}`);

  // ось в x = padLbl
  const axisX = padLbl;

  // общий масштаб по X
  const xMax = opts.sharedMax ?? computeSharedMax([rows]);
  const x = d3.scaleLinear().domain([0, xMax]).range([0, innerW]);

  // линия-ось
  svg.append('line')
    .attr('class','origin-line')
    .attr('x1', axisX).attr('y1', padT - 2)
    .attr('x2', axisX).attr('y2', padT + rows.length*(barH+gap) - gap + 2);

  const g = svg.append('g').attr('transform', `translate(${axisX},${padT})`);

  // path: прямой левый край (у оси), правый скруглён
  function pillRight(yTop, height, width){
    const w = Math.max(0, +width||0);
    if (w <= 0) return '';
    const r = Math.min(height/2, w);
    const xL = 0, xR = w, xRm = w - r;
    const yT = yTop, yB = yTop + height;
    // M 0,yT H w-r Q w,yT w,yT+r V w,yB-r Q w,yB w-r,yB H 0 Z
    return `M ${xL},${yT} H ${xRm} Q ${xR},${yT} ${xR},${yT+r} V ${xR},${yB-r} Q ${xR},${yB} ${xRm},${yB} H ${xL} Z`;
  }

  rows.forEach((d,i)=>{
    const y = i*(barH+gap);
    const half = (barH/2) - 2;

    // фон-дорожка (на всю ширину вправо)
    const trackPath = pillRight(y, barH, innerW);
    g.append('path').attr('d', trackPath).attr('class','bar-track');

    // серия 1 (верх)
    const aW = x(Math.max(0, +d.a||0));
    g.append('path').attr('d', pillRight(y + 1, half, aW)).attr('class','barA-fill');

    // серия 2 (низ)
    const bW = x(Math.max(0, +d.b||0));
    g.append('path').attr('d', pillRight(y + barH - 1 - half, half, bW)).attr('class','barB-fill');

    // значения — сразу ПОСЛЕ соответствующей полосы (справа от неё)
    g.append('text')
      .attr('class','bar-value')
      .attr('x', aW + 8)
      .attr('y', y + 1 + half/2 + .5)
      .attr('text-anchor','start')
      .text(`${fmtTU(d.a)} ${UNIT}`);

    g.append('text')
      .attr('class','bar-value')
      .attr('x', bW + 8)
      .attr('y', y + barH - 1 - half + half/2 + .5)
      .attr('text-anchor','start')
      .text(`${fmtTU(d.b)} ${UNIT}`);
  });

  // подписи показателей — ПЕРЕД линией, справа выравниваем к оси
  const labelsG = svg.append('g').attr('transform', `translate(${axisX - 8},${padT})`);
  labelsG.selectAll('text').data(rows).enter().append('text')
    .attr('class','bar-label')
    .attr('x', 0)
    .attr('y', (_,i)=> i*(barH+gap) + barH/2 + .5)
    .attr('text-anchor', 'end')
    .text(d=> d.label);
}
</script>
