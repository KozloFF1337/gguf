<script>
  // rows: [{label, a(0..100), b(0..100)}]
  function drawDualBars(svgId, rows, opts = {}) {
    const svg = d3.select('#' + svgId);
    svg.selectAll('*').remove();

    // Базовая геометрия
    const barH = opts.barHeight ?? 22;     // общая «дорожка»
    const gap  = opts.gap ?? 10;
    const minPadL = opts.leftPad ?? 100;   // минимальные отступы
    const minPadR = opts.rightPad ?? 56;
    const padT = 8, padB = 12;

    // Ширина viewBox; сам SVG тянется по width:100%
    const W = 320;

    // --- 1) Замеряем реальные ширины подписей/значений, чтобы подобрать паддинги
    const measureG = svg.append('g').attr('opacity', 0);
    const mLabel = measureG.append('text').attr('class', 'bar-label').attr('x', 0).attr('y', 0);
    const mValue = measureG.append('text').attr('class', 'bar-value').attr('x', 0).attr('y', 0);

    const labels = rows.map(d => d.label);
    const valStr = rows.map(d => {
      const a = Math.round(Math.max(0, Math.min(100, d.a)));
      const b = Math.round(Math.max(0, Math.min(100, d.b)));
      return `${a}% / ${b}%`;
    });

    const wLabel = s => { mLabel.text(s); return mLabel.node().getComputedTextLength(); };
    const wValue = s => { mValue.text(s); return mValue.node().getComputedTextLength(); };

    let maxLabelW = 0; labels.forEach(s => maxLabelW = Math.max(maxLabelW, wLabel(s)));
    let maxValueW = 0; valStr.forEach(s => maxValueW = Math.max(maxValueW, wValue(s)));

    let padL = Math.max(minPadL, Math.ceil(maxLabelW) + 14);
    let padR = Math.max(minPadR, Math.ceil(maxValueW) + 8);

    // Страхуемся: оставим минимум ширины под сами бары
    const minInnerW = 80;
    padL = Math.min(padL, W - padR - minInnerW);

    // Если после ограничения подписи не влазят — аккуратно укорачиваем с «…»
    const availLabelW = padL - 12;
    function fitLabelToWidth(s) {
      if (wLabel(s) <= availLabelW) return s;
      let cut = s.trim();
      while (cut.length > 1 && wLabel(cut + '…') > availLabelW) {
        const i = cut.lastIndexOf(' ');
        cut = i > 0 ? cut.slice(0, i) : cut.slice(0, cut.length - 1);
      }
      return cut + '…';
    }
    const fittedLabels = labels.map(fitLabelToWidth);

    // Больше не нужны — можно удалить
    measureG.remove();

    // Итоговые размеры
    const innerW = Math.max(minInnerW, W - padL - padR);
    const H = padT + rows.length * (barH + gap) - gap + padB;

    svg.attr('viewBox', `0 0 ${W} ${H}`);

    const x = d3.scaleLinear().domain([0, 100]).range([0, innerW]);

    const g = svg.append('g').attr('transform', `translate(${padL},${padT})`);

    rows.forEach((d, i) => {
      const y = i * (barH + gap);

      // Фон дорожки
      g.append('rect')
        .attr('class', 'bar-track')
        .attr('x', 0).attr('y', y)
        .attr('width', innerW).attr('height', barH)
        .attr('rx', barH / 2).attr('ry', barH / 2);

      // Верхняя полоса (Серия 1)
      const half = (barH / 2) - 2;
      const aVal = Math.max(0, Math.min(100, +d.a || 0));
      g.append('rect')
        .attr('class', 'barA-fill')
        .attr('x', 0).attr('y', y + 1)
        .attr('width', x(aVal)).attr('height', half)
        .attr('rx', half).attr('ry', half);

      // Нижняя полоса (Серия 2)
      const bVal = Math.max(0, Math.min(100, +d.b || 0));
      g.append('rect')
        .attr('class', 'barB-fill')
        .attr('x', 0).attr('y', y + barH - 1 - half)
        .attr('width', x(bVal)).attr('height', half)
        .attr('rx', half).attr('ry', half);
    });

    // Подписи слева
    const labelsG = svg.append('g').attr('transform', `translate(${padL - 8},${padT})`);
    labelsG.selectAll('text').data(fittedLabels).enter().append('text')
      .attr('class', 'bar-label')
      .attr('x', 0)
      .attr('y', (_, i) => i * (barH + gap) + barH / 2 + .5)
      .text(d => d);

    // Значения справа
    const valsG = svg.append('g').attr('transform', `translate(${padL + innerW + 6},${padT})`);
    valsG.selectAll('text').data(valStr).enter().append('text')
      .attr('class', 'bar-value')
      .attr('x', 0)
      .attr('y', (_, i) => i * (barH + gap) + barH / 2 + .5)
      .attr('text-anchor', 'start')
      .text(d => d);
  }

  // Пример вызовов (оставь как у тебя):
  // drawDualBars('bars-left',  LEFT_BARS2);
  // drawDualBars('bars-right', RIGHT_BARS2);
</script>
